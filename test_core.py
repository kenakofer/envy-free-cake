import unittest
from agent import *
from piece import *
from random import *
from core import *
from time import sleep

class AgentTests(unittest.TestCase):
    
    def test_best_case(self):
        debug_print("Testing identical preferences (best case) for value_count and trim_count")
        divs = 29
        n = 5
        agents = [
            Agent(division_count=divs, preference_function=lambda x: x**2) for i in range(n)
        ]
        pieces = core(agents[0], agents, Piece.get_whole_piece())

        self.assertTrue(agents[0].value_count == 1)
        self.assertTrue(agents[0].trim_count == n-1)
        for a in agents[1:]:
            self.assertTrue(a.value_count == n)
            self.assertTrue(a.trim_count == 0)

    def test_worst_case(self):
        debug_print("Testing a possible worst case call to prints")
        #Values independently generated by Mathematica:
        #Note that 1: 0 is an exceptional case
        #TODO These numbers below are outdated. Our caching has at some point saved some steps (6 queries saved on 6 agent)
        # Also, line 5 in the paper was not properly counted by us, raising the bound.
        #worst_cases_for_n_players = { 1: 0, 2: 4, 3: 12, 4: 34, 5: 94, 6: 255, 7: 682, 8: 1807, 9: 4761, 10: 12505, 11: 32791 }
        for n in range(1,7):
            #print(n)
            divs = 30
            agents = [
                Agent(division_count=divs, preference_function=lambda x: x**i) for i in range(1, n+1)
            ]
            pieces = core(agents[0], agents, Piece.get_whole_piece())
            trim_count = sum([a.trim_count for a in agents])
            value_count = sum([a.value_count for a in agents])
            #print("sum:",trim_count+value_count)
            #self.assertTrue( value_count + trim_count <= worst_cases_for_n_players[n] )

    def test_problem_scenarios(self):
        with open('./problem_scenario', 'r') as f:
            for line in f.readlines():
                agent_strings = line.split(';')
                agents = [Agent() for i in range(len(agent_strings))]
                for i in range(len(agent_strings)):
                    agents[i].set_preferences(agent_strings[i])
                info_line = ''
                for a in agents:
                    info_line += a.get_preference_string() + '; '
                assert info_line[:-2].strip() == line.strip()
                core(agents[0], agents, Piece.get_whole_piece())
                trim_count = sum([a.trim_count for a in agents])
                value_count = sum([a.value_count for a in agents])

    
    def test_preference_powers(self):
        for i in range(5):
            for n in [5]:
                agents = [Agent(division_count=20, preference_function=lambda x: x**Fraction(randint(0,5), randint(1,5))) for j in range(n)]
                pieces = core(agents[0], agents, Piece.get_whole_piece())
                self.assertTrue( True )



    #Ran test on 15 agents: Returned correctly in 1972.634s

    def test_preference_random(self):
        for n in range(2,6):
            agents = [Agent(random.randint(5,23)) for i in range(n)]
            pieces = core(agents[0], agents, Piece.get_whole_piece())
            self.assertTrue( True )

    def test_residue_extraction(self):
        for n in range(20):
            agents = [Agent(random.randint(5,23)) for i in range(6)]
            pieces = core(agents[0], agents, Piece.get_whole_piece())
            residue = Piece.extract_residue_from_pieces(pieces)
            for a in agents:
                pieces_value = sum([a.get_value(p) for p in pieces])
                if residue != None:
                    residue_value = a.get_value(residue)
                else:
                    residue_value = 0
                assert pieces_value + residue_value == 1

    def test_domination_check(self):
        for n in range(20):
            agents = [Agent(random.randint(5,23)) for i in range(6)]
            pieces = core(agents[0], agents, Piece.get_whole_piece())
            residue = Piece.extract_residue_from_pieces(pieces)
            #print(Agent.get_dominating_set(agents, pieces, residue))
    

def main():
    unittest.main()

if __name__ == '__main__':
    main()
